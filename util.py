import inflect
import csv
import os.path

# Enables pluralizing nouns; a less-than-perfect holdover from the Ruby implementation
plu = inflect.engine()

# Working with YAML can be done with either the pyyaml library or the ruamel.yaml library; pyyaml should be deprecated.
use_pyyaml = False

if use_pyyaml:
    import yaml
    from yaml.representer import Representer
    from yaml.dumper import Dumper

    # Necessary stupidity:  https://stackoverflow.com/questions/37200150/can-i-dump-blank-instead-of-null-in-yaml-pyyaml
    class BlankNone(Representer):
        """Print None as blank when used as context manager"""
        def represent_none(self, *_):
            return self.represent_scalar(u'tag:yaml.org,2002:null', u'')

        def __enter__(self):
            self.prior = Dumper.yaml_representers[type(None)]
            yaml.add_representer(type(None), self.represent_none)

        def __exit__(self, exc_type, exc_val, exc_tb):
            Dumper.yaml_representers[type(None)] = self.prior
else:
    import ruamel.yaml
    yaml = ruamel.yaml.YAML()
    yaml.explicit_start = True
    yaml.preserve_quotes = True
    #yaml.default_flow_style = None

    SQ = ruamel.yaml.scalarstring.SingleQuotedScalarString


def write_yaml_file(data, path, write_preamble=True):
    """Writes the given data to a specified YAML file in a standard format, and with a boilerplate preamble identifying
    the file as being generated by POG.

    :param data: the YAML-compatible data to be written
    :param path: the path and filename for the destination file (.YML or .YAML extension should be included)
    """
    preamble = "# This EVE Online overview generated by eve-pog (EVE Python Overview Generator).\n" \
               "# Adapted from 'EVE Online Overview Generator' by Leon Razor.\n" \
               "# Created for Pandemic Horde.\n"

    if use_pyyaml:
        with BlankNone(), open(path, "w") as fileout:
            if write_preamble:
                fileout.write(preamble)
            yaml.safe_dump(data, fileout, allow_unicode=True, sort_keys=False, explicit_start=True)
    else:
        with open(path, "w") as fileout:
            if write_preamble:
                fileout.write(preamble)
            yaml.dump(data, fileout)


def load_yaml_file(subdir, filename):
    """Loads data from a YAML-compatible file, trying both .YML and .YAML extensions.

    :param subdir: subdirectory to look in for the YAML file
    :param filename: filename (without extension) of the YAML file
    :return: the data parsed from the file
    """
    def open_and_read(file):
        with open(file, 'r') as yaml_file:
            if use_pyyaml:
                return yaml.safe_load(yaml_file)
            else:
                return yaml.load(yaml_file)

    file_path = os.path.join(subdir, f"{filename}.yml")
    try:
        return open_and_read(file_path)
    except OSError:
        file_path = os.path.join(subdir, f"{filename}.yaml")
        return open_and_read(file_path)


def load_invcategories():
    """
    Assumes existence of named CSV file from Fuzzwork's SDE conversion. Used for adding comments in output YAML files.
    """
    with open("invCategories.csv", "r") as file:
        cat_rows = list(csv.DictReader(file))
    return {int(row['categoryID']): row['categoryName'] for row in cat_rows}


def load_invgroups():
    """
    Assumes existence of named CSV file from Fuzzwork's SDE conversion. Used for adding comments in output YAML files.
    """
    cats = load_invcategories()

    with open("invGroups.csv", "r") as file:
        rows = list(csv.DictReader(file))
    return {int(row['groupID']): {
        'name': row['groupName'],
        'cat_name': cats[int(row['categoryID'])],
        'cat': int(row['categoryID'])
    } for row in rows}


def write_annotated_groups(filename, types):
    """
    Writes a 'groups' YAML file, consisting of a list of group ID numbers keyed by the string "types", along
    with commented annotations indicating the group name for each entry.
    :param filename: output destination for this file, extension required
    :param types: the list of group IDs
    """
    invgroups = load_invgroups()
    types = sorted(types)
    with open(filename, "w") as fileout:
        fileout.write("---\ntypes:\n")
        for type in types:
            fileout.write(f"  - {type:<10}# {invgroups[type]['name']}\n")
        fileout.write("\n")
    print(f"Wrote to file {filename}")